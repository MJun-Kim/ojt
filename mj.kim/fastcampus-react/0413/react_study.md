#### SPA

- SPA(Single Page Application) : 라우팅을 클라이언트가 담당
  > 라우팅이란 어떤 주소에 어떤 UI를 보여줄지 규칙을 정하는 작업을 의미
- 옛날에는 라우팅 관련 작업은 보통 서버쪽에서 처리했지만 SPA에서는 클라이언트가 관리함
- 장점 ,단점

```
  장점
  1. 필요할 때만 클라이언트가 API요청을 통해 서버와 통신하므로 서버쪽 자원을 아낄 수 있음

  단점
  1. 앱의 규모가 커지면 JS파일의 크기가 너무 커질 수 있다. (해결책 -> Code Splitting)
  2. 브라우저에서 JS가 구동되지 않으면 UI를 볼 수 없다. (자바스크립트가 구동되기 전까진 페이지를 볼 수 없음) (해결책 -> Server Side Rendering)
  3.
```

#### React Router

- 리액트에서 가장 많이 사용되는 라우터 라이브러리(1. react-router, 2. next)

1. react-router

   - 컴포넌트를 기반으로 라우팅
   - \<BorwswerRouter> : HTML5 History API 사용해서 브라우저의 경로를 바꿀때 서버측에 요청 없이 단순히 브라우저측에서 주소만 바꾸는 작업 가능
   - \<HashRouter> : 주소 뒤에 #을 넣는 형태를 사용. 옛날 브라우저에서도 작동 가능
   - \<MemoryRouter> : 브라우저의 주소와 무관하며 일체 건들이지 않아서 브라우저가 아닌 환경에서 사용하기 좋음(ex. 테스트환경, 리액트 네이티브, 임베디드 웹앱 등.)
   - \<staticRouter> : 서버사이드 렌더링에서 사용하는 용도
   - \<Route> : 라우트를 정의할 때 사용한느 컴폰넌트. 즉 '어떤 경로로 들어왔을 때 어떤 컴포넌트를 보여줄거다' 라는 설정을 하는 컴포넌트
   - \<Link> : 사용한 Router의 주소를 바꿈 (\<a>태그로 구성되어 있지만 새로고침 안됨)

2. next

```
  - 서버사이드 렌더링을 엄청나게 쉽게 구현 가능
  - 파일 경로, 이름을 기반으로 라우팅을 함
```

---

### Redux

- 리액트에서 사용률이 가장 높은 상태관리 라이브러리
- Context API + useReducer(Hook) 방법과 유사
- Context와의 차이점

```
  1. 미들웨어
    - 비동기 작업을 더욱 체계적으로 관리 가능
    - 유용한 함수와, Hooks를 지원받을 수 있음(ex. connect, useSelector, useDispatch, useStore 등)
    - 기본적인 최적화가 이미 되어있음
    - DevTools (아주 유용한 개발자 도구가 있음)
    - 특정 조건에 따라 액션이 무시되게 만들 수 있음
    - 액션을 콘솔에 출력하거나, 서버쪽에 로깅을 할 수 있음
    - 액션이 디스패치 됐을 때 이를 수정해서 리듀서에게 전달되도록 할 수 있음
    - 특정 액션이 발생했을 때 이에 기반하여 다른 액션이 발생되도록 할 수 있음
    - 특정 액션이 발생했을 때 특정 자바스크립트 함수를 실행시킬 수 있음
```

- 액션

```
  - 상태에 어떠한 변화가 필요할 때 발생시킴
  - 업데이트해야될 때 어떻게 업데이트해야되는지 정의하는 객체

  {
    type: "TOGGLE_VALUE" // 필수 값
    data: {
      id: 0,
      text: "리덕스 배우기"
    }
  }
```

- 액션 생성함수(Action Creator)

```
  - 액션을 만들어주는 함수
  - 파라미터를 받아와서 액션 객체를 만들어주는 함수
  - 리덕스를 사용할 땐 액션 생성함수가 필수적이진 않지만 액션 생성함수를 만들어 놓으면 나중에 좀 더 편하게 액션 객체를 만들 수 있음

  export function addTodo(data) {
    return {
      type: "ADD_TODO",
      data
    };
  }

  //화살표 함수로도 만들 수 있음
  export const changeInput = (text) => ({
    type: "CHANGE_INPUT,
    text
  });
```

- 리듀서(Reducer)

```
  - 변화를 일으키는 함수
  - state, action 파라미터를 받아옴
  - useReducer를 사용할 땐 default부분에 error를 발생시키는게 일반적이지만 redux reducer에서는 기존의 state그대로 반환하는 형태로 작성해야 됨

  function counter(state, action) {
    switch(action.type) {
      case 'INCREASE':
        return state + 1;
      case 'DECREASE':
        return state - 1;
      default:
        return state;
    }
  }
```

- 스토어(store)

```
  - 리덕스를 사용하게 되면 하나의 앱당 하나의 스토어를 생성
  - 스토어 안에는 현재 앱의 상태와 reducer, 추가적으로 몇가지 내장함수들이 들어있음
  - 그 중에 dispatch가 있는데 '액션을 발생시키는 것' or '액션을 스토어에게 전달한다' 이라고 이해하면 됨

  dispatch({ type: 'INCREASE' })
  - 위와같이 호출을 하면 해당 액션이 리듀서에게 전달되어 리듀서 함수에서 새로운 상태를 반환해주면 스토어 상태가 새로워 짐
```

- subscribe(구독)

```
  - 스토어의 내장함수 중 하나
  - 구독한 함수를 호출할 때 파라미터로 특정 함수를 넣어주면 액션이 디스패치 될 때마다 우리가 설정한 함수가 호출 됨
  - 이를 통해, 스토어의 상태가 업데이트 될 때마다 특정 함수를 호출할 수 있음
  -
```

> - 리덕스의 3가지 규칙
>
> 1. 하나의 앱엔 하나의 스토어가 있어야 한다.
> 2. 상태는 읽기전용 이어야 한다 (즉, 불변성을 지켜줘야 한다.)
> 3. 변화를 일으키는 함수 리듀서는 순수한 함수여야 한다.
>    순수한 함수 : 리듀서 함수는 이전 상태와, 액션 객체를 파라미터로 받음. 이전의 상태는 절대로 변경하지 않고 변화를 일으킨 새로운 상태 객체를 만들어서 반환한다. 똑같은 파라미터로 호출된 리듀서 함수는 언제나 똑같은 결과값을 반환해야만 한다. (동일한 인풋 -> 동일한 아웃풋)
